# -*- coding: utf-8 -*-
# This file was *autogenerated* from the file MillerRabin.sage
from sage.all_cmdline import *   # import sage library
_sage_const_40 = Integer(40); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_100 = Integer(100); _sage_const_128 = Integer(128); _sage_const_12 = Integer(12)
import random

def modpow(b,n,m):          #模重复平方算法计算b^n(mod m)
    a=_sage_const_1 
    while(n!=_sage_const_0 ):
        r=n%_sage_const_2 
        if(r==_sage_const_1 ):
            a=(a*b)%m
        b=(b*b)%m
        n=n//_sage_const_2 
    return a
def mr(n):
    s=_sage_const_0 
    t=n-_sage_const_1 
    while(t%_sage_const_2 ==_sage_const_0 ):          #计算s,t使n-1=(2^s)*t
        s=s+_sage_const_1 
        t=t//_sage_const_2 
    k=_sage_const_0 
    while(k<_sage_const_40 ):            #安全参数为40，每次循环为一次检验
        b=random.randint(_sage_const_2 ,n-_sage_const_1 )     #随机选取2<=b<n-1
        r=modpow(b,t,n)     #计算r=b^t (mod n)
        if(r==_sage_const_1 ):
            continue        #r==1，通过本次检验
        i=_sage_const_0 
        while(i<s):         #r=b^((2^i)*t)
            if(r==n-_sage_const_1 ):     #r==-1 (mod n) 通过本次检验
                break
            r=(r**_sage_const_2 )%n
            i=i+_sage_const_1 
        if(i==s):
            return _sage_const_0         #本次检验不通过，根据Miller-Rabin素性检验法，n为合数
        k=k+_sage_const_1 
    return _sage_const_1                 #通过整个检验，n为（伪）素数

fout=open("output.txt","w")

count=_sage_const_0 
while(count<_sage_const_2 ):             #找两个小于100的（伪）素数
    n=random.randrange(_sage_const_3 ,_sage_const_100 )
    if(mr(n)):
        fout.write(str(n)+'\n')
        count=count+_sage_const_1 

i=_sage_const_2 **_sage_const_128 
while(count<_sage_const_12 ):            #找剩下十个大小为128位二进制的（伪）素数
    n=random.randrange(i+_sage_const_1 ,_sage_const_2 *i,_sage_const_2 )
    if(mr(n)):
        fout.write(str(n)+'\n')
        count=count+_sage_const_1 
    
fout.close()
